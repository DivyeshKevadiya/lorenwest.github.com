{"majorversion": 3, "classmap": {"ConfigTest": {"name": "ConfigTest", "constructors": [{"description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test node-config</pre>"}], "namespace": "", "module": "test", "guessedname": "ConfigTest", "file": "2-config-test.js", "guessedtype": "property", "shortname": "ConfigTest", "description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test node-config</pre>"}, "Config": {"file": "config.js", "description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module is a singleton class representing all runtime\nconfigurations for this application instance.\n</p>\n<p>\nThe require('config') constructor returns the configuration object.\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "namespace": "", "module": "node-config", "methods": {"_attachProtoDeep": {"return": {"type": "", "description": "toObject"}, "description": "Attach the Config class prototype to all config objects recursively.\n<p>\nThis allows you to do anything with CONFIG sub-objects as you can do with\nthe top-level CONFIG object.  It's so you can do this:\n</p>\n<pre>\nvar CUST_CONFIG = require('config').Customer;\nCUST_CONFIG.watch(...)\n</pre>", "protected": "", "params": [{"type": "", "name": "toObject", "description": ""}, {"type": "", "name": "depth", "description": ""}], "guessedname": "_attachProtoDeep", "guessedtype": "function"}, "_watchForConfigFileChanges": {"protected": "", "description": "Monitor the filesystem for configuration file changes.\n<p>\nRuntime configuration changes are made by modifying the runtime.json file.\nThis paradigm allows multiple application servers to internally notify\nlisteners whenever the configuration changes.\n</p>\n<p>\nThis method attaches the file watcher onto the runtime.json file.\n</p>", "guessedname": "_watchForConfigFileChanges", "guessedtype": "function"}, "_diffDeep": {"return": {"type": "object", "description": "A differential object, which if extended onto object1 would\nresult in object2."}, "description": "Returns an object containing all elements that differ between two objects.", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The base object to compare to"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_diffDeep", "guessedtype": "function"}, "watch": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to watch.  Can be any javascript object."}, {"type": "string", "name": "property", "description": "  - The property name to watch.  Watch all object properties if null."}, {"type": "function(object, propertyName, priorValue, newValue)", "name": "handler", "description": "  - Handler called when a property change is detected.\nThe handler is run along with other handlers registered for notification.\nIf the handler changes the value of the property, that change is applied after all handlers have finished processing the current change.\nThen all handlers (including this one) will be called again with the newly changed value."}, {"type": "integer", "name": "depth", "description": "  (optional) - If watching all object properties or if the specified property is an object, this specifies the depth of the object graph to watch for changes.  Default 6."}], "description": "<p>Monitor a configuration value for runtime changes.</p>\n<p>\nConfiguration values can be changed in a running application by the \napplication, or by a manual change to the runtime.json\nfile within the configuration directory. The watch method lets you specify \na function to run if a configuration value changes.  \n</p>\n<p>\nIf you want to prevent changes to configuration values, it's better to use \nthe makePropertyImmutable method.\n</p>\n<p>\nThis method was built for monitoring changes to configuration values,\nbut it can be used for watching changes to any javascript object.\n</p>", "guessedname": "watch", "guessedtype": "function"}, "_equalsDeep": {"return": {"type": "boolean", "description": "True if both objects have equivalent contents"}, "description": "Return true if two objects have equal contents.", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The object to compare from"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_equalsDeep", "guessedtype": "function"}, "makeImmutable": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to attach an immutable property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make immutable."}], "description": "<p>Make a configuration property immutable (assuring it cannot be changed).</p>\n<p>\nThis method was built for configuration properties that shouldn't change,\nbut it can be applied to any javascript object property.\n</p>\n<p>\nThis operation cannot be un-done.\n</p>", "guessedname": "makeImmutable", "guessedtype": "function"}, "_cloneDeep": {"return": {"type": "object", "description": "A new object with the elements copied from the copyFrom object"}, "description": "Return a deep copy of the specified object.\nThis returns a new object with all elements copied from the specified\nobject.  Deep copies are made of objects and arrays so you can do anything\nwith the returned object without affecting the input object.", "protected": "", "params": [{"type": "object", "name": "copyFrom", "description": "  The original object to copy from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_cloneDeep", "guessedtype": "function"}, "_loadFileConfigs": {"protected": "", "return": {"type": "this", "description": "The configuration object"}, "description": "Load the individual file configurations.\n<p>\nThis method builds a map of filename to the configuration object defined\nby the file.  The search order is:\n</p>\n<pre>\ndefault.EXT\n(hostname).EXT\n(deployment).EXT\n(hostname)-(deployment).EXT\nruntime.json\n</pre>\n<p>\nEXT can be yaml, json, or js signifying the file type.  yaml is in YAML format,\njson is in strict JSON format, and js is a javascript executable file that is\nrequire()'d with module.exports being the config object.\n</p>\n<p>\n(hostname) is the $HOST environment variable if set, otherwise the\n$HOSTNAME environment variable if set, otherwise the hostname found from\nrequire('os').hostname()\n</p>\n<p>\n(deployment) is the deployment type, found in the $NODE_ENV environment\nvariable.  Defaults to 'development'.\n</p>\n<p>\nThe runtime.json file contains configuration changes made at runtime via\nthe CONFIG.set('element',value) method.\n</p>", "guessedname": "_loadFileConfigs", "guessedtype": "function"}, "_extendDeep": {"return": {"type": "object", "description": "The altered mergeInto object is returned"}, "description": "Extend an object, and any object it contains.\nThis does not replace deep objects, but dives into them\nreplacing individual elements instead.", "protected": "", "params": [{"type": "object", "name": "mergeInto", "description": "  The object to merge into"}, {"type": "object...", "name": "mergeFrom...", "description": "  - Any number of objects to merge from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_extendDeep", "guessedtype": "function"}, "_isObject": {"return": {"type": "boolean", "description": "TRUE if the arg is an object, FALSE if not"}, "description": "Is the specified argument a regular javascript object?\nThe argument is an object if it's a JS object, but not an array.", "protected": "", "params": [{"type": "MIXED", "name": "arg", "description": "  An argument of any type."}], "guessedname": "_isObject", "guessedtype": "function"}, "_parseFile": {"return": {"type": "configObject", "description": "The configuration object parsed from the file"}, "description": "Parse and return the specified configuration file.\nIf the file exists in the application config directory, it will\nparse and return it as a JavaScript object.\nThe file extension determines the parser to use.\n.js = File to run that has a module.exports containing the config object\n.json = File is parsed using JSON.parse()\n.yaml = Parsed with a YAML parser\nIf the file doesn't exist, a null will be returned.\nIf the file can't be parsed, an exception will be thrown.", "protected": "", "params": [{"type": "string", "name": "fullFilename", "description": "  The full file path and name"}], "guessedname": "_parseFile", "guessedtype": "function"}, "_persistConfigChanges": {"protected": "", "description": "Persist configuration file changes to runtime.json\n<p>\nThis method watches configuration variables for changes, and builds a new\nruntime.json file containing all changes to the original configuration.\n</p>", "guessedname": "_persistConfigChanges", "guessedtype": "function"}}, "guessedname": "Config", "guessedtype": "function", "shortname": "Config", "name": "Config"}, "ProtectedTest": {"name": "ProtectedTest", "constructors": [{"description": "<p>Tests for protected (hackable) utilities.  To run type:</p>\n<pre>npm test node-config</pre>"}], "namespace": "", "module": "test", "guessedname": "PrivateTest", "file": "1-protected-test.js", "guessedtype": "property", "shortname": "ProtectedTest", "description": "<p>Tests for protected (hackable) utilities.  To run type:</p>\n<pre>npm test node-config</pre>"}}, "version": "0.4.0", "modules": {"node-config": {"description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module is a singleton class representing all runtime\nconfigurations for this application instance.\n</p>\n<p>\nThe require('config') constructor returns the configuration object.\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "submodules": [], "classlist": ["Config"], "filelist": ["config.js"], "subdata": {}, "name": "node-config"}, "test": {"description": "<p>Unit tests</p>", "submodules": [], "classlist": ["ProtectedTest", "ConfigTest"], "filelist": ["1-protected-test.js", "2-config-test.js"], "subdata": {}, "name": "test"}}, "filemap": {"2-config-test.js": {"classlist": ["ConfigTest"], "name": "2-config-test.js", "module": "test"}, "config.js": {"classlist": ["Config"], "name": "config.js", "module": "node-config"}, "1-protected-test.js": {"classlist": ["ProtectedTest"], "name": "1-protected-test.js", "module": "test"}}}